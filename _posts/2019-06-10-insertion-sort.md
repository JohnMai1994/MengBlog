---
title: 算法：插入排序Insertion Sort
layout: post
date: '2019-06-12 17:00:00'
category: 算法
tag: Algorithm
---

今天，我将会讲一下插入排序，在看之前，请准备一副扑克牌，谢谢~

## 算法原理
在看下面原理之前，随意捉13张牌，然后从左到右把序列排好，然后再看插入排序的原理，这会大大帮助你理解~

插入排序（Insertion Sort）的工作原理如下:
1. 从第一个元素开始，该元素可以认为已经被排序
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描
3. 如果该元素（已排序）大于新元素，将该元素移到下一位置
4. 重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置
5. 将新元素插入到该位置后
6. 重复步骤 2~5

用比较简单的话来描述，就是一直保证第n个pos之前都是已经被sorted好的序列。

如果元素都位于对的位置上，则元素不会被移动，所以最好的结果Best Case就是不用进行交换，运算时间Running Time: O(1)。最坏的结果Worst Case就是每次都要进行pos-1次交换，运算时间Running Time: O(n^2)。平均运算时间= O(n^2)。
## 举个栗子
现在有一组array = [5, 6, 3, 1, 8, 7, 2, 4]，总共有8个元素，排序过程如下。

**前一个元素**
```java
[5]   6   3   1   8   7   2   4  
```
注意，这时候5，只有1个，所以它是最小的，不用排序

**前两个个元素**
```java
[5   6]   3   1   8   7   2   4
```
[5,6] 还是处于sorted的状态，所以不用排序

**前三个元素**
```java
[5   6   3]   1   8   7   2   4
      ↑   ↑
     └─┘

[5   3   6]   1   8   7   2   4
 ↑   ↑
└─┘

[5   3   6]   1   8   7   2   4
```

如此类推
当第四个的时候，1就不断和前面的元素进行对比，如果1比前一个小，就调换，直至前面的元素比1还小or没有。

如此循环，最终我们得到一个排好序的array(＾－＾)V

这是另外一个例子。。。
<img src="{{ '/assets/blog/insertion-1.png' | prepend: site.baseurl }}" alt="">

## 伪代码
```
for i <- 2 to n
	j <- i
	while j > 1 and A[j] < A[j - 1]
		swap (A[j], A[j - 1])
		j <- j - 1
```